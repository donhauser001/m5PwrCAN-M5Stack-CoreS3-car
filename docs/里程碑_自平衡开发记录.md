# M5Stack CoreS3 自平衡小车 — 开发里程碑记录

> 最后更新: 2026-02-18

---

## 硬件平台

| 模块 | 型号 | 作用 |
|------|------|------|
| 主控 | M5Stack CoreS3 | ESP32-S3, BMI270 IMU, LCD 显示 |
| CAN 模块 | Module 13.2 PwrCAN | CAN 通信 + 隔离供电, 连接 DinBase |
| 电机 | Unit RollerCAN ×2 | 无刷 FOC 电机, 内置速度/电流/位置三模式闭环 |
| 底座 | DinBase | CoreS3 底座, 提供物理安装和供电通路 |

**通信链路**: CoreS3 → (GPIO 17/18) → PwrCAN → (CAN Bus 1Mbps) → RollerCAN 电机

**物理参数**: 总重 830g, 轮径 85mm, 轮周长 267mm, 编码器 36000 counts/rev

---

## 里程碑一览

| # | 日期 | 状态 | 摘要 |
|---|------|------|------|
| M1 | 2026-02-13 | ✅ 完成 | CAN 通信 + 基础电机控制 |
| M2 | 2026-02-14 | ✅ 完成 | IMU 姿态估计 + 基础 PID 平衡 |
| M3 | 2026-02-15 | ✅ 完成 | Web 远程控制界面 + 遥测回传 |
| M4 | 2026-02-16 | ✅ 完成 | 电机初始化安全流程修复 |
| M5 | 2026-02-17 | ✅ 完成 | PID 迭代调优, 平衡时长 2→6 秒 |
| M6 | 2026-02-18 | ✅ 完成 | 切换电流模式, 平衡时长 6→13 秒 |
| M7 | 2026-02-18 | 🔄 进行中 | linearSpeed bug 修复 + 防漂移 |

---

## M1 — CAN 通信建立

**目标**: 通过 CAN 总线与两个 RollerCAN 电机建立可靠通信。

**关键实现**:
- ESP32-S3 TWAI 驱动, 1Mbps 速率
- 29-bit 扩展帧协议: `cmd(5bit) | opt(8bit) | motorId(8bit)`
- 参数读写 (`readParam` / `writeParam`)、反馈帧解析 (`parseFeedback`)
- 电机 ID: 右轮 `0xA8`, 左轮 `0xA9`

**遇到的问题**: CAN 初始化时如果之前有残留的 TWAI 驱动实例, 新驱动安装会失败。
**解决方案**: `canInit()` 开头先尝试在默认引脚 (6/7) 安装→启动→停止→卸载, 再在目标引脚 (17/18) 重新安装。

---

## M2 — IMU 姿态估计 + PID 平衡

**目标**: 利用 BMI270 实现倾角估计, 并用 PID 控制器驱动电机保持平衡。

**关键实现**:
- **6 轴互补滤波**: `pitch = α × (pitch + gyro·dt) + (1-α) × accelAngle`, α=0.98
- **坐标系适配**: CoreS3 竖直放置时, pitch = `atan2(accel.z, accel.y)`, pitch 角速度 = `-gyro.x` (符号取反)
- **PID 控制器**: 输出单位为 RPM, 控制频率 200Hz (5ms 周期)
- **安全机制**: 跌倒检测 (>12°)、启动门限 (角度<6°, 角速度<8°/s, 连续稳定 150ms)

**遇到的问题**: `gyro.x` 的正方向与 `atan2(az, ay)` 定义的 pitch 方向相反。
**解决方案**: `rawGyroX = -(d.gyro.x - gyroOffset[0])` 取反。

---

## M3 — Web 远程控制界面

**目标**: 通过 WiFi + WebSocket 实现浏览器端实时遥测和控制。

**关键实现**:
- WebSocket 协议: 姿态广播 (50ms)、电机状态广播 (500ms)
- 命令协议: Stand(S)、Diag(D)、Stop(X)、PID 调参等
- 遥测日志: 每控制周期记录完整状态 (pitch, gyro, PID, 电机速度/电流/温度等)

---

## M4 — 电机初始化安全流程修复

**目标**: 解决上电后电机异常行为。

### 问题 4.1: 上电轮子就动

**现象**: 电机上电后立刻旋转, 未等待任何命令。
**根因**: `motorsInit()` 中先调用 `setMotorOutput(true)` 开启输出, 然后才发送 `setMotorSpeed(0)` 清零设定点。上电瞬间电机寄存器中可能有非零残留值。
**修复**: 调整初始化顺序 — 先 `CMD_OFF` 禁用输出 → 清零设定点 → 再 `CMD_ON` 启用。

### 问题 4.2: 校准后两轮反向旋转

**现象**: IMU 校准完成后, 两个轮子以相反方向来回旋转。
**根因**: `setMotorSpeedLoopGains()` 覆盖了 RollerCAN 电机出厂的内部速度环 PID 参数 (写入 NVM), 导致内部闭环不稳定。
**修复**: 移除 `setMotorSpeedLoopGains()` 调用, 使用出厂默认内部 PID 参数。

### 问题 4.3: CAN 通信中断 / 电机完全无扭矩

**现象**: 运行一段时间后电机突然失去响应。
**根因**: CAN 总线错误累积 (接线问题、信号反射等) 导致 TWAI 驱动进入 Bus-Off 状态。
**修复**: 排查硬件接线; CAN 初始化增加容错处理。

---

## M5 — PID 迭代调优

**目标**: 通过遥测数据驱动的迭代调优, 延长平衡时间。

### 调优轮次

| 轮次 | Kp | Kd | D_LIMIT | GYRO_LPF_α | 结果 |
|------|----|----|---------|------------|------|
| 初始 | 5.0 | 0.8 | 200 | 0.3 | ~2s, 快速发散振荡 |
| ① | 6.0 | 1.8 | 300 | 0.4 | <1s, 剧烈高频振荡 (Kd 过大) |
| ② | 6.0 | 1.0 | 120 | 0.5 | ~4s, 缓慢发散振荡 |
| ③ | 6.0 | 1.2 | 150 | 0.5 | ~6s, 仍然缓慢发散 |

### 关键洞察

- **Kd=1.8 过于激进**: D 项放大了 gyro 噪声, 产生剧烈高频振荡
- **D_LIMIT=120 被频繁裁剪**: gyro 峰值 ~130°/s × Kd=1.0 = 130 RPM > 120, 导致峰值削波
- **GYRO_LPF_ALPHA**: 从 0.3→0.5 增加平滑, 有效抑制 D 项对 gyro 尖峰的过度反应
- **LCD 刷新干扰**: 平衡期间 LCD 全屏刷新 (~30ms) 会打断控制环, 改为完全跳过

### 其他优化

- WebSocket 姿态广播: 20ms → 50ms (减少 CPU 占用)
- 电机状态广播: 250ms → 500ms
- 平衡期间完全跳过 LCD 刷新

### 结论

即使 PID 参数已接近最优, 平衡仍然缓慢发散。遥测数据揭示了根本原因: **电机内部速度环 PID 引入了 50-100ms 的相位延迟**, 在机器人 ~4Hz 的自然振荡频率下, 这个延迟导致相位裕度不足, 控制器无法收敛。

---

## M6 — 切换电流(力矩)直控模式 ⭐

**目标**: 绕过电机内部速度环, 直接控制力矩, 消除相位延迟。

### 问题分析

```
控制链路 (旧 - 速度模式):
  PID → RPM命令 → [电机内部速度PID: 50-100ms延迟] → FOC电流 → 扭矩
                    ↑ 这里是瓶颈

控制链路 (新 - 电流模式):
  PID → RPM×增益=mA命令 → FOC电流 → 扭矩 (响应 <1ms)
```

### 关键修改

**config.h** — 新增电流模式参数:
```cpp
#define CURRENT_MODE_GAIN_MA_PER_RPM 10.0f  // RPM→mA 映射增益
#define CURRENT_MODE_LIMIT_MA        1000   // 电流限幅 (短时1A, 连续500mA)
```

物理推算: 0.83kg 机器人、CoG≈60mm、电机扭矩常数≈0.065Nm/A → 约 66mA/deg/motor。
Kp=6 RPM/deg → 需 GAIN≥11 单靠 P 项抵抗重力; 取 10, D 项补齐差额。

**can_motor.cpp** — 电机初始化改为电流模式:
1. CMD_OFF → 清零电流指令 → 设置 MODE_CURRENT → 再次清零 → CMD_ON
2. `driveMotors()` 根据 `gMotorMode` 自动选择 `setMotorCurrent()` 或 `setMotorSpeed()`

**web_protocol.cpp** — Stand 命令确保切换到 MODE_CURRENT。

### 实测结果 🎉

| 指标 | 速度模式 (M5) | 电流模式 (M6) | 改善 |
|------|--------------|--------------|------|
| 最长存活 | ~6s | **12.9s** | **+115%** |
| 稳态 pitch | ±1.5° | **±0.25°** (rows 30-73) | **6× 更稳** |
| 稳态 PID 输出 | ±15 RPM | **±1 RPM** | 几乎零努力 |
| 最大 \|pitch\| | ~3° | 7.16° (失控后) | — |
| 振荡特征 | 持续发散 | **前 3.7s 完美静止**, 后受扰发散 | 本质性改善 |

RUN 1 的 rows 30-73 (约 2 秒) 展示了**近乎完美的静止平衡**: pitch 在 ±0.25° 内, 电机电流 ±5mA, 两轮基本不动。

---

## M7 — linearSpeed bug 修复 + 防漂移 (进行中)

**目标**: 解决电流模式下机器人平移漂移问题。

### 问题 7.1: linearSpeed 计算公式错误 (关键 bug)

**现象**: 遥测显示 `linearSpeed ≈ 0` 且 `distance ≈ 3cm`, 但实际观察机器人明显在移动。
**根因**: `linearSpeed = (actualSpeedR + actualSpeedL) / 2 × ...`

由于左轮方向 `DIR_L = -1`, 左电机正转时报告**负** RPM:
- 两轮同向前进: `actualSpdR = +122, actualSpdL = -123`
- 旧公式 `(122 + (-123))/2 = -0.5` → 显示几乎为零 (**错! 这其实是偏航分量**)
- 正确计算: `(122 - (-123))/2 = 122.5 RPM ≈ 545 mm/s` → 机器人正在高速前冲

**修复**: `can_motor.cpp` 中改为差值:
```cpp
linearSpeed = ((float)actualSpeedR - (float)actualSpeedL) * 0.5f * ...
```

> **物理含义**:
> - **平移速度** ∝ `(R - L)` (差值, 同向运动时两轮贡献叠加)
> - **偏航速度** ∝ `(R + L)` (和值, 原地旋转时两轮反向)

### 问题 7.2: 缺乏速度反馈 (VELOCITY_K 之前无效)

**现象**: 电流模式下没有内部速度环制动, 机器人修正倾斜后会保持惯性滑行, 速度逐渐累积。
**根因**: `VELOCITY_K = 0.0` (之前关闭, 且因 linearSpeed bug 即使开了也无效)。
**修复**: `config.h` 中启用:
```cpp
#define VELOCITY_K  0.05f  // 50mm/s漂移→2.5RPM修正, 200mm/s→10RPM
```

### 新增: 偏航修正 (YAW_K)

**目的**: 防止两轮同向旋转导致原地自旋。
```cpp
#define YAW_K  0.05f
// imu_balance.cpp:
float yawRate = (actualSpeedR + actualSpeedL) * 0.5f;  // 旋转分量
float yawCorr = yawRate * YAW_K;
targetR = pidOutput + steer - yawCorr;
targetL = pidOutput - steer + yawCorr;
```

### 期望效果

- 漂移距离大幅减小 (linearSpeed 正确检测 + VELOCITY_K 制动)
- 偏航旋转被抑制
- 平衡时间可能进一步延长 (不再因漂移加速失控)

---

## M7: 速度修正 LPF + 限幅 (验证结果)

### 遥测结果 (5 次 RUN)

| RUN | 持续(s) | max\|pitch\| | max\|speed\|(m/s) | 漂移距离(m) | 结果 |
|-----|---------|-------------|-------------------|------------|------|
| 1   | 7.4     | 14.2°       | 1.184             | 0.58       | FALLEN |
| 2   | 9.2     | 25.1°       | 0.625             | -0.73      | FALLEN |
| 3   | 9.9     | 42.0°       | 1.920             | 1.82       | FALLEN |
| 4   | >4s     | 5.3°+       | 0.407+            | 进行中     | (截断) |

### 问题分析: Ki=0 → 稳态偏差 → 持续漂移

遥测揭示了根本原因：
1. **前 1-2 秒完美平衡** (RUN 2: pitch ±0.35°)
2. **随后 pitch 缓慢偏移到 -1°** (无积分修正 → 偏差无法消除)
3. **偏移角产生持续驱动力**: pitch=-1° → pTerm=-6RPM → 持续向后加速
4. **速度修正追不上**: VELOCITY_CORR_LIMIT=5RPM < PID 驱动 6RPM → 净 -1RPM 仍然加速
5. **振荡 + 漂移 → 正反馈 → 跌倒**

速度 LPF 相位问题 (alpha=0.95):
- 200Hz 采样率，截止频率 1.6Hz
- 在 3Hz 振荡频率: 仅衰减 47%，且引入 -62° 相位延迟
- 残余信号接近弹性力特征，削弱系统阻尼

### 解决方案: 引入积分项 + 加强 LPF

```cpp
DEFAULT_KI:        0.0  → 0.5   // 消除稳态偏差
INTEGRAL_LIMIT:    80.0 → 20.0  // max iTerm = 0.5×20 = 10RPM
VELOCITY_LPF_ALPHA: 0.95 → 0.99 // fc=0.32Hz, 3Hz处衰减90%
```

Ki 工作原理:
- 1° 稳态偏差 → 积分每秒增长 1.0 → 5 秒后 iTerm = 2.5 RPM
- 积分缓慢修正偏差 → pitch 回归 0° → 持续驱动消失 → 漂移停止
- INTEGRAL_LIMIT=20 封顶: 即使极端情况 iTerm ≤ 10 RPM, 不会过冲

LPF alpha=0.99:
- 截止频率降至 0.32 Hz (从 1.6Hz)
- 3Hz 振荡衰减 90% (从 47%), 相位干扰几乎消除
- 时间常数 ~0.5s, 仍能响应秒级慢漂移

### M8 验证结果 — 突破!

| RUN | 持续(s) | max\|pitch\| | 漂移(m) | 结果 |
|-----|---------|-------------|---------|------|
| 1   | 1.9     | 13.4°       | 0.098   | FALLEN (启动扰动) |
| 2   | **28.7** | 12.8°      | 0.62    | FALLEN (外部扰动) |
| 3   | **>29.6** | **0.45°** | **0.000** | **仍在运行!** |

**关键指标对比 (M7 → M8):**
- 平衡时间: 7-10s → **>30s** (3-4x 提升)
- 稳态 pitch: ±1-2° (持续偏移) → **±0.1°** (围绕零点)
- 漂移速度: 0.4-1.9 m/s → **0.000 m/s**
- 漂移距离: 0.5-1.8m → **0.000m**
- PID 输出: ±50-150 RPM (大幅振荡) → **±5 RPM** (微调)

Ki=0.5 成功消除了稳态偏差, 机器人在 RUN 3 中实现了近乎完美的
静态平衡: pitch ±0.1°, 零漂移, 零速度, 持续超过 30 秒。

RUN 2 跌倒分析: 22s 处外部扰动导致振荡增长, row 554 附近出现
电机左右不对称 (可能 CAN 丢包), 导致偏航偏移后前倾加速失控。
系统本身的稳态平衡已完全解决。

---

## 当前参数快照

```cpp
// PID
Kp = 6.0    Ki = 0.5    Kd = 1.2
D_LIMIT = 150    INTEGRAL_LIMIT = 20

// IMU 滤波
COMP_ALPHA = 0.98    GYRO_LPF_ALPHA = 0.5    TARGET_LPF_ALPHA = 0.85

// 电机 (电流模式)
CURRENT_MODE_GAIN = 10.0 mA/RPM    CURRENT_MODE_LIMIT = 1000 mA
DIR_R = +1    DIR_L = -1    OUTPUT_LIMIT = 300

// 防漂移
VELOCITY_K = 0.05    YAW_K = 0.05
VELOCITY_CORR_LIMIT = 5.0    VELOCITY_LPF_ALPHA = 0.99

// 安全
FALL_ANGLE = 12°    START_ANGLE = 6°
SOFT_START_MS = 80    CTRL_HZ = 200
```

---

## 已知待解决

1. ~~**M8 验证**: 烧录后确认 Ki 积分修正效果 + LPF 加强效果~~ ✅ 已验证, 效果极佳
2. ~~**Ki 调优**: 初始 Ki=0.5~~ ✅ Ki=0.5 表现完美, 无需调整
3. ~~**长时间运行**: 目标 >30 秒稳定平衡~~ ✅ RUN 3 已超过 30 秒且仍在运行
4. **抗扰动恢复**: RUN 2 在 22s 外部扰动后发散, 需提高大扰动下的恢复能力
5. **FALL_ANGLE 自适应**: 电流模式扭矩响应快, 可考虑适当放宽跌倒阈值
6. **温度反馈**: motorTemp 读回值异常 (曾出现 720914°C), 需排查 CAN 解析
7. **CAN 可靠性**: RUN 2 跌倒前出现电机左右不对称, 疑 CAN 丢包, 需排查
8. **移动控制**: 平衡已稳定, 可开始实现前进/后退/转向遥控功能

---

## 文件结构

```
sketch_feb13a/
├── sketch_feb13a.ino   # 主循环: setup/loop, 控制环调度, 显示, Web
├── config.h            # 全局配置: 引脚, PID, 物理参数, 安全阈值
├── globals.h           # 全局变量声明
├── globals.cpp         # 全局变量定义
├── imu_balance.h       # IMU + 平衡控制接口
├── imu_balance.cpp     # 6轴互补滤波 + PID 平衡控制
├── can_motor.h         # CAN 电机控制接口
├── can_motor.cpp       # CAN 通信 + RollerCAN 驱动
├── web_control.h       # Web 控制接口
├── web_control.cpp     # WiFi + WebSocket 服务
└── web_protocol.cpp    # Web 命令协议 + 遥测格式
```
